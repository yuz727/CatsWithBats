/// Imports
use crate::game::npc::*;
use crate::game::pathfinding::*;

use bevy::prelude::*;
use rand::prelude::*;

use super::components::Ball;
use super::components::BallVelocity;
use super::components::Player;

/// Constants for movement calculation
const NPC_SIZE: f32 = 30.;
const NPC_SPEED: f32 = 300.;
const NPC_ACCEL_RATE: f32 = 18000.;

/// Return whether a ball is going to hit the npc
pub fn danger_check(
    npc_translation: Vec3,
    time: &Res<Time>,
    ball_query: &Query<
        (&Transform, &BallVelocity, &Ball),
        (With<Ball>, Without<NPC>, Without<NPCBat>, Without<Player>),
    >,
) -> bool {
    // For every ball
    for (ball_transform, ball_velocity, ball) in ball_query.iter() {
        // If a ball is close enough (< 200 pixels away) and it is moving towards the npc, then return true
        let ball_future_position = Vec2::new(
            (ball_transform.translation.x + (ball_velocity.velocity.x * time.delta_seconds()))
                .clamp(-(1280. / 2.) + ball.radius, 1280. / 2. - ball.radius),
            (ball_transform.translation.y + (ball_velocity.velocity.y * time.delta_seconds()))
                .clamp(-(720. / 2.) + ball.radius, 720. / 2. - ball.radius),
        );
        if ball_transform.translation.distance(npc_translation) < 200.
            && ball_future_position.distance(npc_translation.truncate())
                < ball_transform.translation.distance(npc_translation)
        {
            return true;
        }
    }
    return false;
}

/// NPC movement in danger state, sidestep to avoid getting hit by ball
pub fn sidestep(mut npc: Query<(&mut Transform, &mut NPCVelocity), With<NPC>>) {
    for (npc_transform, velocity) in npc.iter_mut() {}
}

/// Return whether player is < 200 pixels in distance to the NPC
pub fn player_proximity_check(npc_translation: Vec3, player_translation: Vec3) -> bool {
    // If player is close enough (< 200 pixels away) and it is moving towards the npc, then return true
    if player_translation.distance(npc_translation) < 200. {
        return true;
    }
    return false;
}

/// Return whether
pub fn tag_is_null(path: &Path) -> bool {
    // Implement TAG null check logic
    if path.goal.x == -1. && path.goal.y == -1. {
        return true;
    }
    return false;
}

/// Find the closest ball to NPC, and set the goal to it.
pub fn set_tag_to_closest_ball(
    npc_translation: Vec3,
    path: &mut Path,
    ball_query: &Query<
        (&Transform, &BallVelocity, &Ball),
        (With<Ball>, Without<NPC>, Without<NPCBat>, Without<Player>),
    >,
) -> bool {
    let mut ret = Vec2::splat(10000000000.);
    for (ball_transform, _, _) in ball_query.iter() {
        if ball_transform.translation.distance(npc_translation)
            < npc_translation.truncate().distance(ret)
        {
            ret = ball_transform.translation.truncate();
        }
    }
    if ret.x == 10000000000. && ret.y == 10000000000. {
        return false;
    }
    path.goal = ret;
    return true;
}

pub fn target_check() {}
/// Return a random check on difficulty
pub fn difficulty_check(difficulty: i32) -> bool {
    let mut rand = thread_rng();
    if difficulty > rand.gen_range(0.0..100.0) as i32 {
        return true;
    }
    return false;
}

// fn aggression_check(mut npcs: Query<&States, With<NPC>>) -> bool {
//     return true;
// }

pub fn swing_cooldown_check(swing_timer: &mut NPCTimer, time: &Res<Time>) -> bool {
    swing_timer.tick(time.delta());
    if swing_timer.just_finished() {
        return true;
    }
    return false;
}

pub fn set_tag_to_closest_object(npc_translation: Vec3, path: &mut Path) -> bool {
    // Implement setting TAG to the closest object logic
    // return NodeStatus::Success;
    let recliner_distance = npc_translation.distance(Vec3::new(-60., 210., 1.));
    let table_distance = npc_translation.distance(Vec3::new(120., 170., 1.));
    let tv_distance = npc_translation.distance(Vec3::new(0., -250., 1.));
    let recliner_size = Vec2::new(109., 184.);
    let recliner_translation = Vec3::new(-60., 210., 1.);
    let tv_size = Vec2::new(164., 103.);
    let tv_translation = Vec3::new(0., -245., 1.);
    let table_size = Vec2::new(103., 107.);
    let table_translation = Vec3::new(120., 170., 1.);

    return true;
}

/// Set NPC's goal to the player
pub fn set_tag_to_player(path: &mut Path, player_translation: Vec3) {
    path.goal = player_translation.truncate().floor();
}

/// Generate a new path using A*
pub fn set_a_star(npc_translation: Vec3, path: &mut Path, maps: &Maps) {
    let goal = path.goal;
    path.set_new_path(a_star(
        coords_conversion_astar(npc_translation.truncate().floor()),
        coords_conversion_astar(goal),
        maps,
    ));
}

/// Movement for Aggression and Evade state, move along the path generated by A*
pub fn perform_a_star(
    mut npcs: Query<
        (&mut Transform, &mut NPCVelocity, &mut Path, &Maps),
        (With<NPC>, Without<Player>, Without<NPCBat>),
    >,
    mut bat: Query<&mut Transform, (With<NPCBat>, Without<Player>, Without<NPC>)>,
    player: Query<&Transform, (With<Player>, Without<NPCBat>, Without<NPC>)>,
    time: Res<Time>,
) {
    for (mut npc_transform, mut velocity, mut path, maps) in npcs.iter_mut() {
        for mut bat_transform in bat.iter_mut() {
            for player_transform in player.iter() {
                //  for mut face_transform in face.iter_mut() {
                let Some(Vec2 { x, y }) = path.path.pop() else {
                    return;
                };

                let mut deltav = Vec2::splat(0.);
                if npc_transform.translation.x < x {
                    deltav.x += 1000.;
                }
                if npc_transform.translation.x > x {
                    deltav.x -= 1000.;
                }
                if npc_transform.translation.y < y {
                    deltav.y += 1000.;
                }
                if npc_transform.translation.y > y {
                    deltav.y -= 1000.;
                }

                let deltat = time.delta_seconds();
                let acc = NPC_ACCEL_RATE * deltat;
                velocity.velocity = if deltav.length() > 0. {
                    (velocity.velocity + (deltav.normalize_or_zero() * acc))
                        .clamp_length_max(NPC_SPEED)
                } else if velocity.velocity.length() > acc {
                    velocity.velocity + (velocity.velocity.normalize_or_zero() * -acc)
                } else {
                    Vec2::splat(0.)
                };

                velocity.velocity = collision_check(
                    npc_transform.translation,
                    velocity.velocity,
                    player_transform.translation,
                );
                velocity.velocity = velocity.velocity * deltat;

                npc_transform.translation.x = (npc_transform.translation.x + velocity.velocity.x)
                    .clamp(-(1280. / 2.) + NPC_SIZE / 2., 1280. / 2. - NPC_SIZE / 2.);
                npc_transform.translation.y = (npc_transform.translation.y + velocity.velocity.y)
                    .clamp(-(720. / 2.) + NPC_SIZE / 2., 720. / 2. - NPC_SIZE / 2.);

                // Fixes Misalign
                if npc_transform.translation.x != x || npc_transform.translation.y != y {
                    npc_transform.translation.x = x;
                    npc_transform.translation.y = y;
                }
                bat_transform.translation.x = npc_transform.translation.x - 5.;
                bat_transform.translation.y = npc_transform.translation.y;
            } // for
        } // for
    } // for
}

pub fn swing(
    mut npcs: Query<
        (
            &mut Transform,
            &mut NPCVelocity,
            &mut Path,
            &Maps,
            &Difficulty,
            &mut AnimationTimer,
        ),
        With<NPC>,
    >,
    ball_query: Query<&Transform, With<Ball>>,
) {
    // Implement swing logic
    // return NodeStatus::Success;
}

/// Check whether collision happened, modify velocity if needed
pub fn collision_check(
    npc_translation: Vec3,
    mut velocity: Vec2,
    player_translation: Vec3,
) -> Vec2 {
    let recliner_size = Vec2::new(112., 184.);
    let recliner_translation = Vec3::new(-60., 210., 1.);
    let recliner = bevy::sprite::collide_aabb::collide(
        recliner_translation,
        recliner_size,
        npc_translation,
        Vec2::new(NPC_SIZE, NPC_SIZE),
    );

    let tv_size = Vec2::new(164., 104.);
    let tv_translation = Vec3::new(0., -250., 1.);
    let tv_stand = bevy::sprite::collide_aabb::collide(
        tv_translation,
        tv_size,
        npc_translation,
        Vec2::new(NPC_SIZE, NPC_SIZE),
    );

    let table_size = Vec2::new(104., 108.);
    let table_translation = Vec3::new(120., 170., 1.);
    let side_table = bevy::sprite::collide_aabb::collide(
        table_translation,
        table_size,
        npc_translation,
        Vec2::new(NPC_SIZE, NPC_SIZE),
    );

    let player_collision = bevy::sprite::collide_aabb::collide(
        player_translation,
        Vec2::new(NPC_SIZE, NPC_SIZE),
        npc_translation,
        Vec2::new(NPC_SIZE, NPC_SIZE),
    );

    if recliner == Some(bevy::sprite::collide_aabb::Collision::Right) {
        velocity.x = -1. * 0.8;
    } else if recliner == Some(bevy::sprite::collide_aabb::Collision::Left) {
        velocity.x = 1. * 0.8;
    } else if recliner == Some(bevy::sprite::collide_aabb::Collision::Top) {
        velocity.y = -1. * 0.8;
    } else if recliner == Some(bevy::sprite::collide_aabb::Collision::Bottom) {
        velocity.y = 1. * 0.8;
    }

    if tv_stand == Some(bevy::sprite::collide_aabb::Collision::Left) {
        velocity.x = 1. * 0.9;
    } else if tv_stand == Some(bevy::sprite::collide_aabb::Collision::Right) {
        velocity.x = -1. * 0.9;
    } else if tv_stand == Some(bevy::sprite::collide_aabb::Collision::Top) {
        velocity.y = -1. * 0.9;
    } else if tv_stand == Some(bevy::sprite::collide_aabb::Collision::Bottom) {
        velocity.y = 1. * 0.9;
    }

    if side_table == Some(bevy::sprite::collide_aabb::Collision::Left) {
        velocity.x = 1. * 0.85;
    } else if side_table == Some(bevy::sprite::collide_aabb::Collision::Right) {
        velocity.x = -1. * 0.85;
    } else if side_table == Some(bevy::sprite::collide_aabb::Collision::Top) {
        velocity.y = -1. * 0.85;
    } else if side_table == Some(bevy::sprite::collide_aabb::Collision::Bottom) {
        velocity.y = 1. * 0.85;
    }

    if player_collision == Some(bevy::sprite::collide_aabb::Collision::Left) {
        velocity.x = 1. * 0.85;
    } else if player_collision == Some(bevy::sprite::collide_aabb::Collision::Right) {
        velocity.x = -1. * 0.85;
    } else if player_collision == Some(bevy::sprite::collide_aabb::Collision::Top) {
        velocity.y = -1. * 0.85;
    } else if player_collision == Some(bevy::sprite::collide_aabb::Collision::Bottom) {
        velocity.y = 1. * 0.85;
    } else if player_collision == Some(bevy::sprite::collide_aabb::Collision::Inside) {
        velocity.x = -1. * 0.85;
        velocity.y = -1. * 0.85;
    }

    return velocity;
}
